<!DOCTYPE html>
<html>

<head>
    <title>Nodegraph</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
</head>

<body class="container-fluid" style="background:lightblue">
    <div class="row">
        <div id='nodegraph' class='col-12' style="min-height: 50vh;"></div>
        <div class="col-12">
            <textarea id="jsonData" rows=10 cols=50></textarea><br />
            <button id="update-btn" class="btn btn-success pull-right">Update</button>
        </div>
    </div>



    <!-- JavaScript -->
    <script type='module'>
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
        import map from "https://cdn.jsdelivr.net/npm/d3@7/+esm";  
        // JSON data from text input 
        var jsonData = document.getElementById('jsonData').value;
        // Parse the data into a graph object  
        var graphObject = JSON.parse(jsonData);
        var _ = window._;


        //Function to render the force graph:

        function ForceGraph({
            nodes, // an iterable of node objects (typically [{id}, …])
            links // an iterable of link objects (typically [{source, target}, …])
        }, {
            nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)
            nodeGroup, // given d in nodes, returns an (ordinal) value for color
            nodeGroups, // an array of ordinal values representing the node groups
            nodeTitle = d => d.id, // given d in nodes, a title string
            nodeFill = "green", // node stroke fill (if not using a group color encoding)
            nodeStroke = "black", // node stroke color
            nodeStrokeWidth = 1.5, // node stroke width, in pixels
            nodeStrokeOpacity = 1, // node stroke opacity
            nodeRadius = 10, // node radius, in pixels
            nodeStrength,
            linkSource = ({
                from
            }) => from, // given d in links, returns a node identifier string
            linkTarget = ({
                to
            }) => to, // given d in links, returns a node identifier string
            linkStroke = "blue", // link stroke color
            linkStrokeOpacity = 0.6, // link stroke opacity
            linkStrokeWidth = 1.5, // given d in links, returns a stroke width in pixels
            linkStrokeLinecap = "round", // link stroke linecap
            linkStrength,
            colors = d3.schemeTableau10, // an array of color strings, for the node groups
            width = '100', // outer width, in percent
            height = '100' // outer height, in percent
        } = {}) {

            
            // Compute values.
            const N = d3.map(nodes, nodeId).map(intern);
            const LS = d3.map(links, linkSource).map(intern);
            const LT = d3.map(links, linkTarget).map(intern);
            if (nodeTitle === undefined) nodeTitle = (_, i) => N[i];
            const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
            const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);
            const W = typeof linkStrokeWidth !== "function" ? null : d3.map(links, linkStrokeWidth);
            const L = typeof linkStroke !== "function" ? null : d3.map(links, linkStroke);
            
            // console.dir(links,{depth:null});


            // Replace the input nodes and links with mutable objects for the simulation.
            nodes = d3.map(nodes, (_, i) => ({
                id: N[i]
            }));

            links = d3.map(links, (_, i) => ({
                source: LS[i],
                target: LT[i]
            }));
            
            
            
            // Compute default domains.
            if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);
            
            // Construct the scales.
            const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

            // Construct the forces.
            const forceNode = d3.forceManyBody();
            const forceLink = d3.forceLink(links).id(({index: i}) => {
                return N[i];
            });


            if (nodeStrength !== undefined) forceNode.strength(nodeStrength);
            if (linkStrength !== undefined) forceLink.strength(linkStrength);
            
            
            const simulation = d3.forceSimulation(nodes)
            .force("link", forceLink)
            .force("charge", forceNode)
            .force("center", d3.forceCenter())
            .on("tick", ticked);
            
            const svg = d3.create("svg")
                .attr("width", width+'%')
                .attr("height", height+'%')
                .attr("viewBox", [0 , 0, '100%', '100%'])
                .attr("id", "svg-graph");
                // .attr("style", "min-width: 100%; min-height: 100%; height: intrinsic;");

            const link = svg.append("g")
                .attr("stroke", typeof linkStroke !== "function" ? linkStroke : null)
                .attr("stroke-opacity", linkStrokeOpacity)
                .attr("stroke-width", typeof linkStrokeWidth !== "function" ? linkStrokeWidth : null)
                .attr("stroke-linecap", linkStrokeLinecap)
                .selectAll("line")
                .data(links)
                .join("line");

            const node = svg.append("g")
                .attr("fill", nodeFill)
                .attr("stroke", nodeStroke)
                .attr("stroke-opacity", nodeStrokeOpacity)
                .attr("stroke-width", nodeStrokeWidth)
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("r", nodeRadius)
                .call(drag(simulation));

            if (W) link.attr("stroke-width", ({index: i}) => W[i]);
            if (L) link.attr("stroke", ({index: i}) => L[i]);
            if (G) node.attr("fill", ({index: i}) => color(G[i]));
            if (T) node.append("title").text(({index: i}) => T[i]);
            if (invalidation != null) invalidation.then(() => simulation.stop());

            function intern(value) {
                return value !== null && typeof value === "object" ? value.valueOf() : value;
            }

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            }

            function drag(simulation) {
                function dragstarted(event) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                }

                function dragged(event) {
                    console.log(event);
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                }

                function dragended(event) {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                }

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
            }

            ticked(); // render now!
            return Object.assign(svg.node(), {
                scales: {
                    color
                }
            });
        }
        function main()  {
            console.log('main()')

            var flatGraphObject = { 
                nodes:[],
                edges:[] 
                };
            
            _.map(graphObject, (value, index) => {
                flatGraphObject.nodes.push(value.nodes);
            flatGraphObject.edges.push(value.edges);
        });
        
        flatGraphObject.nodes = _.uniq(_.flatten(flatGraphObject.nodes));
        flatGraphObject.edges = _.flatten(flatGraphObject.edges);

        console.dir (flatGraphObject, {depth:null})

        let newGraph = ForceGraph(flatGraphObject.nodes,flatGraphObject.edges) ({
            nodes:flatGraphObject.nodes,
            links:flatGraphObject.edges
        });

        document.getElementById('update-btn').addEventListener('click', main);
        
        try {
            var svgGraph = document.getElementById('svg-graph');
            if (svgGraph.hasChildNodes()) {document.getElementById('svg-graph').append(newGraph);}
            else {
                document.getElementById('svg-graph').replaceChild(svgGraph, newGraph);
            }
        } catch (e) {
            console.error(e);
        }
    }

    main();
    </script>
</body>

</html